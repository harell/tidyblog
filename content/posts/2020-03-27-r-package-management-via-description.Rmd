---
title: "R Package Management via DESCRIPTION"
author: "Harel Lustiger"
date: '2020-03-27'
output: word_document
bibliography: references-posts.bib
draft: yes
link-citations: yes
categories:
- R Projects
- Reproducible R
slug: r-package-management-via-description
tags:
- package management
- DESCRIPTION
biblio-style: apalike
---

```{r, include = FALSE}
path_root <- rprojroot::find_root(rprojroot::has_file("DESCRIPTION"))
source(file.path(path_root, "R/post_options.R"))
```

## Synopsis

**In This Post**

* Using a package manager that capitalises on existing infrastructure. 
* Forming a discipline of grooming the `DESCRIPTION` file
<!-- * Managing R package dependencies in Docker. -->

<!-- Who should read this post? Any person who needs a simple way to manager R -->
<!-- packages dependencies. -->

<!-- What makes the approach simple? familiarity and existing toolbox -->

The approach in a nutshell:

1. Maintaining package requirements in a `DESCRIPTION` file; 
2. Setting the URL from which to pull the packages from; and
3. Using `remotes::install_deps()` to install the required packages.

## Introduction

All R applications have requirements which are necessary for them to run. A
predominant type of requirement is package dependencies. Most R applications are
built upon R packages which do not come with a fresh installation of R. Thus, to
ensure an R application will run on different computers, it is necessary to
manage its package dependencies. There are a few possible package management
strategies to employ. A common thread of these strategies is the installation of
missing R packages.

R workhorse function for installing R packages is `utils::install.packages()`. A
glimpse into the function help documentation shows us what input arguments
impact the function behaviour.

```{r install.packages, echo = TRUE, eval = FALSE}
install.packages(pkgs, lib, repos = getOption("repos"),
                 contriburl = contrib.url(repos, type),
                 method, available = NULL, destdir = NULL,
                 dependencies = NA, type = getOption("pkgType"),
                 configure.args = getOption("configure.args"),
                 configure.vars = getOption("configure.vars"),
                 clean = FALSE, Ncpus = getOption("Ncpus", 1L),
                 verbose = getOption("verbose"),
                 libs_only = FALSE, INSTALL_opts, quiet = FALSE,
                 keep_outputs = FALSE, ...)
```

Primarily, the first three arguments `pkgs`, `lib` and `repos` specify what to
install, where to install it and where to get it from, respectively. Among
different package management strategies, `pkgs` should be (almost) identical.
However, the methods employed for gathering `pkgs` varies between strategies.
The other two input arguments `lib` and `repos` vary considerably by their
values and generating mechanism between different strategies.

## Recipe

### Ingredients

* The [`remotes`](https://github.com/r-lib/remotes) package;
* The [`usethis`](https://github.com/r-lib/usethis/) package; and
* A `DESCRIPTION` file.

You can install both packages at once by running:

```{r, echo = TRUE, eval = FALSE}
install.packages(c("remotes", "usethis"))
```

You can create a new `DESCRIPTION` file by running:

```{r, echo = TRUE, eval = FALSE}
usethis::use_description()
```

### Directions

#### Grooming the `DESCRIPTION` file

As the R application evolves, anytime an additional package is required for the
application to work, specify that packages in the `DESCRIPTION` file. You can
add a package to the `DESCRIPTION` file by running[^dplyr]:

```{r, echo = TRUE, eval = FALSE}
usethis::use_package("dplyr")
```

Alternatively, you can declare the package name and minimum version by running:

```{r, echo = TRUE, eval = FALSE}
usethis::use_package("dplyr", min_version = "0.8.0")
```

`usethis::use_package` takes care of syntax, duplication and typos (both in
package name and version) for you.

Removing a package from the `DESCRIPTION` file is done manually. Open
`DESCRIPTION` and delete the package name from the `Imports` fields. Make sure
the last package in `Imports` doesn’t end with a comma (',').

#### Installing Package Requirements

Firstly, replicate the package versions that were available at the time of
developing the program. Following this step increases application behaviour
consistency regardless of the date it is executed.

(recommended) You can specify `repos` to point at a snapshot in time of CRAN by
running:

```{r, echo = TRUE, eval = FALSE}
options(repos = "https://mran.microsoft.com/snapshot/2020-03-27")
```

(replace _2020-03-27_ with the date required for reproducibility)

If you skip that step, R installs the latest package versions on the hosting
computer.

Lastly, Given an R project with a `DESCRIPTION` file in the root folder, when
`remotes::install_deps()` is called, then R tries to install the listed packages
within DESCRIPTION.

The following is an extract from the output console:

```
> remotes::install_deps()

Installing packages into ‘/usr/local/lib/R/site-library’
(as ‘lib’ is unspecified)

trying URL 'https://mran.microsoft.com/snapshot/2020-03-27/src/contrib/dplyr_0.8.5.tar.gz'
Content type 'application/octet-stream' length 3229510 bytes (3.1 MB)
==================================================
downloaded 3.1 MB
```

Notice that `remotes::install_deps`:

* Searches and pulls the `dplyr` package from the `repos` address we have
provided it; and

* Installs `dplyr` version 0.8.5. 
    * While we declared the minmum version to be 0.8.3 in `DESCRIPTION`, the
    available version on _2020-03-27_ is 0.8.5.
    * remotes::install_deps fails if any declared minimum version is not
    available; otherwise it installs the latest available version on `repos`.

## References

[^dplyr]: These commands add `dplyr` to the `DESCRIPTION` file.

