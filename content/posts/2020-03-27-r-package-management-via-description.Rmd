---
title: R Package Management via DESCRIPTION
author: Harel Lustiger
date: '2020-03-27'
draft: true
slug: package-management-in-r-via-description
categories:
  - R Projects
  - Reproducible R
tags:
  - package management
  - DESCRIPTION
bibliography: [references-posts.bib]
biblio-style: apalike
link-citations: yes  
---

```{r, include = FALSE}
path_root <- rprojroot::find_root(rprojroot::has_file("DESCRIPTION"))
source(file.path(path_root, "R/post_options.R"))
```

## Synopsis

**In This Post**

* Using a package manager that capitalises on existing infrastructure. 
* Forming a discipline of grooming the `DESCRIPTION` file
<!-- * Managing R package dependencies in Docker. -->

<!-- Who should read this post? Any person who needs a simple way to manager R -->
<!-- packages dependencies. -->

<!-- What makes the approach simple? familiarity and existing toolbox -->

The approach in a nutshell:

1. Maintaining package requirements in a `DESCRIPTION` file; 
2. Setting the URL from which to pull the packages from; and
3. Using `remotes::install_deps()` to install the required packages.

## Introduction

All R applications have requirements which are necessary for them to run. A
predominant type of requirement is package dependencies. Most R applications are
built upon R packages which do not come with a fresh installation of R. Thus, to
ensure an R application will run on different computers, it is necessary to
manage its package dependencies. There are a few possible package management
strategies to employ. A common thread of these strategies is the installation of
missing R packages.

R workhorse function for installing R packages is `utils::install.packages()`. A
glimpse into the function help documentation shows us what input arguments
impact the function behaviour.

```
install.packages(pkgs, lib, repos = getOption("repos"),
                 contriburl = contrib.url(repos, type),
                 method, available = NULL, destdir = NULL,
                 dependencies = NA, type = getOption("pkgType"),
                 configure.args = getOption("configure.args"),
                 configure.vars = getOption("configure.vars"),
                 clean = FALSE, Ncpus = getOption("Ncpus", 1L),
                 verbose = getOption("verbose"),
                 libs_only = FALSE, INSTALL_opts, quiet = FALSE,
                 keep_outputs = FALSE, ...)
```

Primarily, the first three arguments `pkgs`, `lib` and `repos` specify what to
install, where to install it and where to get it from, respectively. Among
different package management strategies, `pkgs` should be (almost) identical.
However, the methods employed for gathering `pkgs` varies between strategies.
The other two input arguments `lib` and `repos` vary considerably by their
values and generating mechanism between different strategies.

## Recipe

### Ingredients

* The [`remotes`](https://github.com/r-lib/remotes) package;
* The [`usethis`](https://github.com/r-lib/usethis/) package; and
* A `DESCRIPTION` file.

You can install both packages at once by running:

```{r, echo = TRUE, eval = FALSE}
install.packages(c("remotes", "usethis"))
```

You can create a new `DESCRIPTION` file by running:

```{r, echo = TRUE, eval = FALSE}
usethis::use_description()
```

### Directions

#### Grooming the `DESCRIPTION` file

As the R application evolves, anytime an additional package is required for the
application to work, specify that packages in the `DESCRIPTION` file. You can
add a package to the `DESCRIPTION` file by running[^dplyr]:

```{r, echo = TRUE, eval = FALSE}
usethis::use_package("dplyr")
```

Alternatively, you can declare the package name and minimum version by running:

```{r, echo = TRUE, eval = FALSE}
usethis::use_package("dplyr", min_version = "0.8.3")
```

`usethis::use_package` takes care of syntax, duplication and typos (both in
package name and version) for you.

Removing a package from the `DESCRIPTION` file is done manually. Open
`DESCRIPTION` and delete the package name from the `Imports` fields. Make sure
the last package in `Imports` doesn’t end with a comma (',').

#### Installing Package Requirements

First, replicate the package versions that were available at the time of
developing the program. Following this step increases application behaviour
consistency regardless of the date it is executed.

(recommended) You can specify `repos` to point at a snapshot in time of CRAN by
running:

```{r, echo = TRUE, eval = FALSE}
options(repos = "https://mran.microsoft.com/snapshot/2020-03-27")
```

(replace _2020-03-27_ with the date required for reproducibility)

If you skip that step, the latest R packages will be installed on the hosting
computer.

Second, it is possible to direct R where to look for and install in R packages.
R starts up with one or more sensible default values, usually pointing at a user
library[^library] and a system library. In addition to system and user
libraries, consider an additional scope – project library. Project library
comprises R packages which are not shared with other projects.

(optional) You can add a project library by running[^R_LIBS_PROJECT]:

```{r, echo = TRUE, eval = FALSE}
Sys.setenv(R_LIBS_PROJECT = "./cache")
.libPaths(Sys.getenv("R_LIBS_PROJECT"))
```

You will also need to declare the project library in ... (Rproject?)

## References

[^dplyr]: These commands add `dplyr` to the `DESCRIPTION` file.
[^library]: A library is a folder with a collection of installed R packages.
[^R_LIBS_PROJECT]: This command will consider a project subfolder named _cache_
where R packages will be looked for and installed in.
