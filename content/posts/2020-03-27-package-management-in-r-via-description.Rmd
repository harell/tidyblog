---
title: Package Management in R via DESCRIPTION
author: Harel Lustiger
date: '2020-03-27'
draft: true
slug: package-management-in-r-via-description
categories:
  - R Projects
  - Reproducible R
tags:
  - dependency management
  - package reproducibility
  - package management
bibliography: [references-posts.bib]
biblio-style: apalike
link-citations: yes  
---

```{r, include = FALSE}
path_root <- rprojroot::find_root(rprojroot::has_file("DESCRIPTION"))
source(file.path(path_root, "R/post_options.R"))
```

## Introduction

All R-applications have requirements which are necessary for them to run. A
predominant type of requirement is package dependencies. Most R-applications are
built upon R packages which do not come with a fresh installation of R. Thus, to
ensure any R application will run on different computers, its package
dependencies must be managed. There are a few possible package management
strategies to employ. A common thread of these strategies is the installation of
missing packages.

R workhorse function for installing packages is `utils::install.packages()`. A
glimpse into the function help documentation shows us what input arguments
impact the function behaviour.

```
install.packages(pkgs, lib, repos = getOption("repos"),
                 contriburl = contrib.url(repos, type),
                 method, available = NULL, destdir = NULL,
                 dependencies = NA, type = getOption("pkgType"),
                 configure.args = getOption("configure.args"),
                 configure.vars = getOption("configure.vars"),
                 clean = FALSE, Ncpus = getOption("Ncpus", 1L),
                 verbose = getOption("verbose"),
                 libs_only = FALSE, INSTALL_opts, quiet = FALSE,
                 keep_outputs = FALSE, ...)
```

Primarily, the first three arguments `pkgs`, `lib` and `repos` specify what to
install, where to install it and where to get it from, respectively. One
possible way to discuss the elementary parts of a package management strategy is
to think about these input arguments roles.

Any package management strategy must identify the packages names required for
the R-application to work. This information is passed into `pkgs`.

## Synopsis

**In This Post**

* Using a package manager that capitalises on existing infrastructure. 
* Forming a discipline of grooming the `DESCRIPTION` file
* Managing R package dependencies in Docker.

Who should read this post? Any person who needs a simple way to manager R
packages dependencies.

<!-- What makes the approach simple? familiarity and existing toolbox -->

The approach in a nutshell:

1. Maintaining package requirements in a `DESCRIPTION` file; 
2. Setting the URL from which to pull the packages from; and
3. Using `remotes::install_deps()` to install the required packages.

## Recipe

### Ingredients

* The [`remotes`](https://github.com/r-lib/remotes) package; and
* The [`usethis`](https://github.com/r-lib/usethis/) package; and
* A `DESCRIPTION` file.

You can install both packages at once by running:

```{r, echo = TRUE, eval = FALSE}
install.packages(c("remotes", "usethis"))
```

You can create a new `DESCRIPTION` file by running:

```{r, echo = TRUE, eval = FALSE}
usethis::use_description()
```

### Directions

#### Grooming the `DESCRIPTION` file

As the R-application evolves, anytime an additional package is required for the
application to work, specify that packages in the `DESCRIPTION` file. You can
add a package to the `DESCRIPTION` file by running:

```{r, echo = TRUE, eval = FALSE}
usethis::use_package("dplyr")
```

Alternatively, you can declare the package name and minimum version by running:

```{r, echo = TRUE, eval = FALSE}
usethis::use_package("dplyr", min_version = "0.8.3")
```

`usethis::use_package` takes care of syntax, duplication and typos (both in
package name and version) for you.

Removing a package from the `DESCRIPTION` file is done manually. Open
`DESCRIPTION` and delete the package name from the `Imports` fields. Make sure
the last package in `Imports` doesnâ€™t end with a comma (',').

#### Installing Package Requirements



## What is a `DESCRIPTION` File?

The `DESCRIPTION` is a file comprising metadata about a specific R package. Having
a `DESCRIPTION` file in a package root folder is a prerequisite for any R package.
The following is an excerpt of the
[ggplot2](https://github.com/tidyverse/ggplot2/blob/v3.2.1/DESCRIPTION)
DESCRIPTION file.

```
Package: ggplot2
Version: 3.2.1
Title: Create Elegant Data Visualisations Using the Grammar of Graphics
Description: A system for 'declaratively' creating graphics,
based on "The Grammar of Graphics". You provide the data, tell 'ggplot2'
how to map variables to aesthetics, what graphical primitives to use,
and it takes care of the details.
Authors@R: person("Hadley","Wickham", ,"hadley@rstudio.com",c("aut", "cre"))
Imports: 
digest,
grDevices,
grid,
gtable (>= 0.1.1),
lazyeval
```

DESCRIPTION uses an archaic file format called DCF (Debian control format) which
was available during R inception. DCF is somewhat similar to YAML in its
structure. Each line consists of a field name paired with one or more values
separated by a colon. When values span multiple lines, they need to be indented
by four spaces.

Different mechanisms in R are using different sections of the `DESCRIPTION` file.
For example, in RStudio under the package tab, the package name, description and
version correspond to the Package, Title and Version fields specified in the
DESCRIPTION file. The following figure is a snapshot from RStudio reporting the
above `DESCRIPTION` file content.


```{r ggplot2-metadata-in-RStudio}
knitr::include_graphics('https://i.imgur.com/gxuSNpZ.png')
```

## Declaring Package Dependencies 

The mechanism for checking and installing the required packages uses the
**Imports** field within the `DESCRIPTION` file. In the case of `ggplot2` (see
figure above), the requirements include `digest`, `grDevices`, `grid`, and
`gtable (>= 0.1.1) `. The parenthesis with the greater equal sign after `gtable`
specifies the package minimum version. In general, including the minimum
version is a good practice. This is because some bug fixes or new features
become available from a certain version and forward.

While you can, manage the `DESCRIPTION` file manually, two R packages mitigate the
workflow. Importantly, they reduce syntax errors and run without having the
DESCRIPTION file open.



```{r, echo = FALSE, results = 'asis', eval=FALSE}
pkgs <- c("usethis", "remotes")
pkgs <- sessioninfo::package_info(pkgs, dependencies = FALSE)
tibble::tibble(
  package = pkgs$package,
  version = pkgs$ondiskversion,
  source = gsub("@", "\\\\@", pkgs$source)) %>% 
  dplyr::select(-source) %>% 
  knitr::kable() %>% 
  kableExtra::kable_styling(
    bootstrap_options = "striped", 
    full_width = TRUE, 
    position = "left"
  )
```